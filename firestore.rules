rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
  
    // Helper function to check auth
    function isAuthenticated() {
      return request.auth != null;
    }
    
    // Helper to check if user matches uid
    function isOwner(uid) {
      return isAuthenticated() && request.auth.uid == uid;
    }
    
    // Basic user roles helper
    function getUserRole() {
      return get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role;
    }
    
    function isAdmin() {
      return isAuthenticated() && getUserRole() == "admin";
    }
    
    function isManager() {
      return isAuthenticated() && getUserRole() == "manager";
    }
    
    // --- USERS Collection ---
    // Users can read/write their own data. 
    // Admins can read/write all.
    match /users/{userId} {
      allow read, write: if isOwner(userId) || isAdmin();
      
      // Subcollections (tasks, todos)
      match /tasks/{taskId} {
          allow read, write: if isOwner(userId) || isAdmin() || isManager();
      }
      match /todos/{todoId} {
          allow read, write: if isOwner(userId) || isAdmin() || isManager();
      }
    }

    // --- TEAMS Collection ---
    match /teams/{teamId} {
      // Create: Admin or Manager
      allow create: if isAdmin() || isManager();
      
      // Read: If you are a member of the team OR admin/manager (simplified)
      // Since mapping queries is hard in rules (array contain check), we rely on client filters for list, 
      // but for specific doc read we check resource.data.members... wait, members is complex array.
      // We added `memberUids` specifically for this!
      allow read: if isAuthenticated() && (isAdmin() || request.auth.uid in resource.data.memberUids);
      
      // Update: Admin, Manager, or Team Admin (if we tracked that separately, but for now app users with Admin/Manager role)
      // Or maybe the 'createdBy' user?
      allow update: if isAdmin() || (isManager() && resource.data.createdBy == request.auth.uid);
      
      match /tasks/{taskId} {
         allow read, write: if isAuthenticated() && (isAdmin() || request.auth.uid in get(/databases/$(database)/documents/teams/$(teamId)).data.memberUids);
      }
    }
    
    // --- PROJECTS Collection ---
    match /projects/{projectId} {
      // Create: Admin or Manager
      allow create: if isAdmin() || isManager();
      
      // Read: If member of the team the project belongs to
      allow read: if isAuthenticated() && (isAdmin() || 
          // Check if user is in the team. Requires get() on team.
          request.auth.uid in get(/databases/$(database)/documents/teams/$(resource.data.teamId)).data.memberUids
      );
      
      // Update: Admin or Manager or Team creator
      allow update: if isAdmin() || isManager();
      
      match /tasks/{taskId} {
           // Allow access if user is in the team of the project
           allow read, write: if isAuthenticated() && (isAdmin() || 
             request.auth.uid in get(/databases/$(database)/documents/teams/$(get(/databases/$(database)/documents/projects/$(projectId)).data.teamId)).data.memberUids
           );
      }
    }
    
    // --- INVITES Collection ---
    match /invites/{inviteId} {
        // Create: Admin or Manager
         allow create: if isAdmin() || isManager();
         
         // Read: If it's your email or you are admin/manager
         // Note: email isn't in request.auth, so we might need to trust the query or claim.
         // For now, allow reading pending invites if authenticated (simplification) or matching email?
         // We can't verify 'request.auth.token.email' unless we trust it. Firebase Auth token has email.
         allow read: if isAuthenticated() && (
             isAdmin() || isManager() || resource.data.email == request.auth.token.email
         );
         
         allow update: if isAuthenticated(); // For accepting status
    }
  }
}
